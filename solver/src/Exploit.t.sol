// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console} from "forge-std/Test.sol";
import {Master} from "src/Exploit.sol";
import {ILandOfTheLustrous} from "src/ILandOfTheLustrous.sol";

contract ExploitTest is Test {
    address playerAddr = makeAddr("player");
    address lunarianAddr = makeAddr("lunarian");
    ILandOfTheLustrous public land;

    function setUp() public {
        vm.deal(playerAddr, 1.5 ether);
        vm.deal(lunarianAddr, 1_000_000 ether);
        vm.startPrank(lunarianAddr, lunarianAddr);
        land = ILandOfTheLustrous(deployCode("challenge/land_of_the_lustrous.vy", 1_000_000 ether));
        vm.stopPrank();
    }

    function test() public {
        vm.startPrank(playerAddr, playerAddr);
        Master master = new Master{value: 1 ether}(address(land));
        vm.stopPrank();

        bool master_turn = true;
        for (uint256 i = 0; i < 100; i++) {
            vm.roll(i);
            console.log();
            console.log("block", i);
            console.log("stage", land.stage(), "indicator", master.indicator());

            if (master_turn) {
                console.log("master turn");
                vm.startPrank(playerAddr, playerAddr);
                try master.prepareBattle() {
                    master_turn = false;
                } catch Error(string memory reason) {
                    console.log(reason);
                }
                vm.stopPrank();
            } else {
                console.log("lunarian turn");
                vm.startPrank(lunarianAddr, lunarianAddr);
                uint256 rounds = 100 * (uint256(land.stage()) + 1);
                uint8[] memory lunarian_actions = new uint8[](rounds);
                bytes32 tmp = keccak256(abi.encode(block.number));
                for (uint256 j = 0; j < rounds; j++) {
                    lunarian_actions[j] = uint8(uint256(tmp) % 3);
                    tmp = keccak256(abi.encode(tmp));
                }
                try land.battle(lunarian_actions) {
                    master_turn = true;
                } catch Error(string memory reason) {
                    console.log(reason);
                }
                vm.stopPrank();
            }

            if (land.is_solved()) {
                console.log("solved");
                break;
            }
        }

        require(land.is_solved(), "not solved");
    }
}

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {ILandOfTheLustrous, Gem} from "./ILandOfTheLustrous.sol";

contract Master {
    bytes constant PAYLOAD_ZERO_100 =
        hex"00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000064";
    bytes constant PAYLOAD_ZERO_200 =
        hex"000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000c8";
    bytes constant PAYLOAD_COPY =
        hex"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb4400000000000000000000000000000000000000000000000000000000000000000";
    int256 constant ACTIVE_HEALTH_THRESHOLD = 64;

    ILandOfTheLustrous land;
    uint8 public indicator = 0;

    constructor(address landAddr) payable {
        require(msg.value == 1 ether);
        land = ILandOfTheLustrous(landAddr);
        land.register_master();
    }

    function prepareBattle() public {
        int256 threshold = 150;
        if (indicator == 0) {
            // stage 0
            Gem memory gem = land.create_gem{value: 1 ether}();
            require(gem.health > threshold && gem.attack > threshold && gem.hardness > threshold, "bad gem");
            land.assign_gem(0);
        } else if (indicator == 1) {
            // stage 1
            // nop
        } else if (indicator == 2) {
            // stage 0
            Gem memory gem = land.create_gem{value: 1 ether}();
            require(gem.health > threshold && gem.attack > threshold && gem.hardness > threshold, "bad gem");
            land.assign_gem(1);
        } else if (indicator == 3) {
            if (land.stage() == 1) {
                // if gem 1 wins without being inactive in the previous battle
                land.pray_gem();
                land.assign_gem(0);
                indicator -= 2; // -> indicator 2
            } else {
                land.assign_gem(0);
            }
        } else if (indicator == 4) {
            if (land.stage() == 1) {
                // if gem 0 wins without being destroyed in the previous battle
                // normally battle gem 0 to destroy
                indicator--; // -> indicator 4
            }
        }
        indicator++;
    }

    // sneak_case since the signature is specified in the Vyper contract
    function decide_continue_battle(uint256, /* round */ int256 /* lunarian_health */ ) public returns (bool) {
        if (indicator == 1) {
            revert("reset round 1, loss");
        } else if (indicator == 3) {
            Gem memory gem = land.gems(getGemId(1));
            require(0 <= gem.health && gem.health < ACTIVE_HEALTH_THRESHOLD, "reset round 2, not inactive");
        } else if (indicator == 4) {
            Gem memory gem0 = land.gems(getGemId(0));
            Gem memory gem1 = land.gems(getGemId(1));
            require(gem0.health + gem1.health < 0, "reset round 3, must be negative");
            land.merge_gems();
        }
        return false;
    }

    function getGemId(uint32 sequence) internal view returns (bytes32) {
        bytes20 master_bytes = bytes20(address(this));
        bytes4 sequence_bytes = bytes4(sequence);
        return keccak256(abi.encodePacked(master_bytes, sequence_bytes));
    }

    receive() external payable {}

    fallback(bytes calldata /* input */ ) external returns (bytes memory output) {
        if (msg.sig == bytes4(keccak256(bytes("get_actions()")))) {
            if (indicator == 1) {
                require(land.stage() == 0, "stage 0");
                return PAYLOAD_ZERO_100;
            } else if (indicator == 2) {
                require(land.stage() == 1, "stage 1");
                return PAYLOAD_COPY;
            } else if (indicator == 3) {
                require(land.stage() == 0, "stage 0");
                return PAYLOAD_ZERO_100;
            } else if (indicator == 4) {
                if (land.stage() == 0) {
                    return PAYLOAD_ZERO_100;
                } else {
                    return PAYLOAD_ZERO_200;
                }
            } else {
                return PAYLOAD_COPY;
            }
        }
    }
}
